"""Gmsh-based adaptive mesh refinement module for meshwell.

This module provides functionality to adaptively refine meshes generated by meshwell
based on target size fields, following the approach from gmsh_adapt_mesh.
Complements the existing MMG-based remesh.py module.
"""

from __future__ import annotations

import numpy as np
from pathlib import Path
from typing import Callable
import gmsh
import meshio


def triangle_max_edge(x: np.ndarray) -> np.ndarray:
    """Calculate maximum edge length for triangular elements.

    Args:
        x: Array of shape (n_triangles, 3, 3) containing triangle vertex coordinates

    Returns:
        Array of maximum edge lengths for each triangle
    """
    a = np.sum((x[:, 0, :] - x[:, 1, :]) ** 2, 1) ** 0.5
    b = np.sum((x[:, 0, :] - x[:, 2, :]) ** 2, 1) ** 0.5
    c = np.sum((x[:, 1, :] - x[:, 2, :]) ** 2, 1) ** 0.5
    return np.maximum(a, np.maximum(b, c))


def tetrahedron_max_edge(x: np.ndarray) -> np.ndarray:
    """Calculate maximum edge length for tetrahedral elements.

    Args:
        x: Array of shape (n_tetrahedra, 4, 3) containing tetrahedron vertex coordinates

    Returns:
        Array of maximum edge lengths for each tetrahedron
    """
    # Calculate all 6 edge lengths for each tetrahedron
    edges = []
    # Edges: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3)
    for i in range(4):
        for j in range(i + 1, 4):
            edge_length = np.sum((x[:, i, :] - x[:, j, :]) ** 2, 1) ** 0.5
            edges.append(edge_length)

    # Stack all edges and find maximum for each tetrahedron
    edges = np.stack(edges, axis=1)  # Shape: (n_tetrahedra, 6)
    return np.max(edges, axis=1)


class MeshExtractor:
    """Extract mesh data from existing mesh files for remeshing."""

    def __init__(self, mesh_file: Path | str):
        """Initialize mesh extractor.

        Args:
            mesh_file: Path to input mesh file (.msh format)
        """
        self.mesh_file = Path(mesh_file) if mesh_file else None
        if self.mesh_file and not self.mesh_file.exists():
            raise FileNotFoundError(f"Mesh file not found: {self.mesh_file}")

        self.vtags: np.ndarray = None
        self.vxyz: np.ndarray = None
        self.triangles_tags: np.ndarray = None
        self.triangles: np.ndarray = None
        self.tetrahedra_tags: np.ndarray = None
        self.tetrahedra: np.ndarray = None
        self.dimension: int = None

    def load_from_gmsh_model(self) -> None:
        """Load mesh data from current gmsh model."""
        self.vtags, vxyz, _ = gmsh.model.mesh.getNodes()
        self.vxyz = vxyz.reshape((-1, 3))
        vmap = dict({j: i for i, j in enumerate(self.vtags)})

        # Try to load tetrahedra first (3D elements)
        try:
            self.tetrahedra_tags, evtags_3d = gmsh.model.mesh.getElementsByType(4)
            if len(self.tetrahedra_tags) > 0:
                evid_3d = np.array([vmap[j] for j in evtags_3d])
                self.tetrahedra = evid_3d.reshape((self.tetrahedra_tags.shape[-1], -1))
                self.dimension = 3
                return
        except:  # noqa: E722
            pass

        # Fall back to triangles (2D elements)
        try:
            self.triangles_tags, evtags_2d = gmsh.model.mesh.getElementsByType(2)
            if len(self.triangles_tags) > 0:
                evid_2d = np.array([vmap[j] for j in evtags_2d])
                self.triangles = evid_2d.reshape((self.triangles_tags.shape[-1], -1))
                self.dimension = 2
                return
        except:  # noqa: E722
            pass

        raise RuntimeError("No triangular or tetrahedral elements found in mesh")

    def get_elements(self) -> tuple[np.ndarray, np.ndarray]:
        """Get element connectivity and tags based on mesh dimension."""
        if self.dimension == 3:
            return self.tetrahedra, self.tetrahedra_tags
        elif self.dimension == 2:
            return self.triangles, self.triangles_tags
        else:
            raise RuntimeError("Mesh dimension not determined")

    def load_from_file(self) -> None:
        """Load mesh data from mesh file using gmsh."""
        if not self.mesh_file:
            raise ValueError("No mesh file specified")
        # Don't initialize here, assume gmsh is already initialized by caller
        gmsh.open(str(self.mesh_file))
        self.load_from_gmsh_model()


def compute_interpolation_error(
    nodes: np.ndarray,
    triangles: np.ndarray,
    target_function: Callable[[np.ndarray], np.ndarray],
) -> tuple[np.ndarray, np.ndarray]:
    """Compute interpolation error for finite element approximation.

    Args:
        nodes: Node coordinates array of shape (n_nodes, 3)
        triangles: Triangle connectivity array of shape (n_triangles, 3)
        target_function: Function to approximate, takes coordinates and returns values

    Returns:
        Tuple of (nodal_function_values, element_errors)
    """
    uvw, weights = gmsh.model.mesh.getIntegrationPoints(2, "Gauss2")
    jac, det, pt = gmsh.model.mesh.getJacobians(2, uvw)
    numcomp, sf, _ = gmsh.model.mesh.getBasisFunctions(2, uvw, "Lagrange")
    sf = sf.reshape((weights.shape[0], -1))
    qx = pt.reshape((triangles.shape[0], -1, 3))
    det = np.abs(det.reshape((triangles.shape[0], -1)))
    f_vert = target_function(nodes)
    f_fem = np.dot(f_vert[triangles], sf)
    err_tri = np.sum((f_fem - target_function(qx)) ** 2 * det * weights, 1)
    return f_vert, np.sqrt(err_tri)


def compute_interpolation_error_3d(
    nodes: np.ndarray,
    tetrahedra: np.ndarray,
    target_function: Callable[[np.ndarray], np.ndarray],
) -> tuple[np.ndarray, np.ndarray]:
    """Compute interpolation error for 3D finite element approximation.

    Args:
        nodes: Node coordinates array of shape (n_nodes, 3)
        tetrahedra: Tetrahedron connectivity array of shape (n_tetrahedra, 4)
        target_function: Function to approximate, takes coordinates and returns values

    Returns:
        Tuple of (nodal_function_values, element_errors)
    """
    uvw, weights = gmsh.model.mesh.getIntegrationPoints(4, "Gauss2")
    _, det, pt = gmsh.model.mesh.getJacobians(4, uvw)
    _, sf, _ = gmsh.model.mesh.getBasisFunctions(4, uvw, "Lagrange")
    sf = sf.reshape((weights.shape[0], -1))
    qx = pt.reshape((tetrahedra.shape[0], -1, 3))
    det = np.abs(det.reshape((tetrahedra.shape[0], -1)))
    f_vert = target_function(nodes)
    f_fem = np.dot(f_vert[tetrahedra], sf)
    err_tet = np.sum((f_fem - target_function(qx)) ** 2 * det * weights, 1)
    return f_vert, np.sqrt(err_tet)


def compute_size_field(
    nodes: np.ndarray,
    elements: np.ndarray,
    err: np.ndarray,
    target_elements: int,
    dimension: int = 2,
) -> np.ndarray:
    """Compute target size field from interpolation errors.

    Args:
        nodes: Node coordinates array
        elements: Element connectivity array (triangles or tetrahedra)
        err: Element-wise error estimates
        target_elements: Target number of elements for remesh
        dimension: Mesh dimension (2 for triangles, 3 for tetrahedra)

    Returns:
        Element-wise target size field
    """
    x = nodes[elements]
    a = 2.0
    d = float(dimension)  # Use mesh dimension for spatial dimension
    fact = (a ** ((2.0 + a) / (1.0 + a)) + a ** (1.0 / (1.0 + a))) * np.sum(
        err ** (2.0 / (1.0 + a))
    )
    ri = (
        err ** (2.0 / (2.0 * (1 + a)))
        * a ** (1.0 / (d * (1.0 + a)))
        * ((1.0 + a) * target_elements / fact) ** (1.0 / d)
    )

    if dimension == 3:
        max_edges = tetrahedron_max_edge(x)
        # Avoid division by zero and extremely small sizes
        ri_safe = np.maximum(ri, 1e-6 * np.max(ri))  # Ensure ri is not too small
        size_field = max_edges / ri_safe
        # Clamp size field to reasonable bounds - maximum aggressive refinement
        min_size = 0.00001 * np.mean(max_edges)  # Extremely fine minimum size
        max_size = 10.0 * np.mean(max_edges)  # Large contrast between fine/coarse
        return np.clip(size_field, min_size, max_size)
    else:
        max_edges = triangle_max_edge(x)
        ri_safe = np.maximum(ri, 1e-6 * np.max(ri))
        size_field = max_edges / ri_safe
        min_size = 0.00001 * np.mean(max_edges)
        max_size = 10.0 * np.mean(max_edges)
        return np.clip(size_field, min_size, max_size)


class GmshAdaptiveMesher:
    """Main class for gmsh-based adaptive mesh refinement."""

    def __init__(
        self,
        input_mesh_file: Path | str,
        input_cad_file: Path | str,
        model_name: str = "adaptive_mesh",
    ):
        """Initialize adaptive mesher.

        Args:
            input_mesh_file: Path to input mesh file from meshwell
            input_cad_file: Path to input CAD file (.xao) from meshwell
            model_name: Name for gmsh model
        """
        self.input_mesh_file = Path(input_mesh_file)
        self.input_cad_file = Path(input_cad_file)
        self.model_name = model_name

        if not self.input_mesh_file.exists():
            raise FileNotFoundError(f"Mesh file not found: {self.input_mesh_file}")
        if not self.input_cad_file.exists():
            raise FileNotFoundError(f"CAD file not found: {self.input_cad_file}")

        self.mesh_extractor = MeshExtractor(self.input_mesh_file)

    def load_initial_mesh(self) -> MeshExtractor:
        """Load the initial mesh data."""
        self.mesh_extractor.load_from_file()
        return self.mesh_extractor

    def compute_error(
        self, target_function: Callable[[np.ndarray], np.ndarray]
    ) -> tuple[np.ndarray, np.ndarray]:
        """Compute interpolation error for current mesh."""
        if self.mesh_extractor.vxyz is None:
            self.load_initial_mesh()

        elements, _ = self.mesh_extractor.get_elements()

        if self.mesh_extractor.dimension == 3:
            return compute_interpolation_error_3d(
                self.mesh_extractor.vxyz, elements, target_function
            )
        else:
            return compute_interpolation_error(
                self.mesh_extractor.vxyz, elements, target_function
            )

    def generate_size_field(self, err: np.ndarray, target_elements: int) -> np.ndarray:
        """Generate size field from error estimates."""
        elements, _ = self.mesh_extractor.get_elements()
        return compute_size_field(
            self.mesh_extractor.vxyz,
            elements,
            err,
            target_elements,
            self.mesh_extractor.dimension,
        )

    def create_size_field_view(
        self, size_field: np.ndarray, view_name: str = "size_field"
    ) -> int:
        """Create gmsh view from size field data.

        Args:
            size_field: Element-wise size field values
            view_name: Name for the view

        Returns:
            View index in gmsh
        """
        view_idx = gmsh.view.add(view_name)

        # Get current model name from gmsh
        current_models = gmsh.model.list()
        if current_models:
            current_model = current_models[0]  # Use first available model
        else:
            current_model = self.model_name

        _, element_tags = self.mesh_extractor.get_elements()
        gmsh.view.addModelData(
            view_idx,
            0,
            current_model,
            "ElementData",
            element_tags,
            size_field[:, None],
        )
        # Smooth the size field
        gmsh.plugin.setNumber("Smooth", "View", gmsh.view.getIndex(view_idx))
        gmsh.plugin.run("Smooth")
        return view_idx

    def remesh_with_size_field(
        self,
        size_field_view: int,
        output_file: Path | str | None = None,
        mesh_algorithm: int = 2,
    ) -> MeshExtractor:
        """Generate new mesh using size field as background mesh.

        Args:
            size_field_view: gmsh view index containing size field
            output_file: Optional output file path
            mesh_algorithm: gmsh meshing algorithm

        Returns:
            New mesh extractor with refined mesh
        """
        # Create new model for remeshing
        new_model_name = f"{self.model_name}_refined"
        gmsh.model.add(new_model_name)

        # Load CAD geometry
        gmsh.merge(str(self.input_cad_file))

        # Set up background mesh field
        bg_field = gmsh.model.mesh.field.add("PostView")
        gmsh.model.mesh.field.setNumber(bg_field, "ViewTag", size_field_view)
        gmsh.model.mesh.field.setAsBackgroundMesh(bg_field)

        # Generate new mesh with more aggressive settings
        gmsh.option.setNumber("Mesh.Algorithm", mesh_algorithm)
        gmsh.option.setNumber("Mesh.CharacteristicLengthFromPoints", 0)
        gmsh.option.setNumber("Mesh.CharacteristicLengthFromCurvature", 0)
        gmsh.option.setNumber("Mesh.CharacteristicLengthExtendFromBoundary", 0)
        gmsh.option.setNumber("Mesh.CharacteristicLengthMax", 1e22)  # No upper limit
        gmsh.option.setNumber("Mesh.CharacteristicLengthMin", 0)  # No lower limit
        gmsh.model.mesh.generate(self.mesh_extractor.dimension)

        if output_file:
            gmsh.write(str(output_file))

        # Extract new mesh data
        new_extractor = MeshExtractor("")  # Empty path since we're loading from model
        new_extractor.load_from_gmsh_model()

        return new_extractor


def gmsh_adaptive_remesh(
    input_mesh_file: Path | str,
    input_cad_file: Path | str,
    target_function: Callable[[np.ndarray], np.ndarray],
    target_elements: int,
    output_mesh_file: Path | str | None = None,
    verbosity: int = 0,
) -> meshio.Mesh:
    """Perform gmsh-based adaptive mesh refinement.

    Args:
        input_mesh_file: Path to input mesh file from meshwell
        input_cad_file: Path to input CAD file (.xao) from meshwell
        target_function: Function to optimize mesh for
        target_elements: Target number of elements
        output_mesh_file: Output refined mesh file path
        verbosity: gmsh verbosity level
        gui: Show gmsh GUI for visualization

    Returns:
        Refined mesh as meshio object
    """
    # Check if gmsh is already initialized
    try:
        gmsh.model.list()
        already_initialized = True
    except:  # noqa: E722
        already_initialized = False
        gmsh.initialize()

    gmsh.option.setNumber("General.Terminal", verbosity)

    try:
        mesher = GmshAdaptiveMesher(input_mesh_file, input_cad_file)

        # Load initial mesh
        mesh = mesher.load_initial_mesh()

        # Compute error
        _, err_elements = mesher.compute_error(target_function)

        # Generate size field
        size_field = mesher.generate_size_field(err_elements, target_elements)

        # Create size field view
        sf_view = mesher.create_size_field_view(size_field, "size_field")

        # Remesh
        mesh = mesher.remesh_with_size_field(sf_view, output_mesh_file)

        # Update mesher with new mesh for next iteration
        mesher.mesh_extractor = mesh

        # Write final mesh if output file specified
        if output_mesh_file:
            gmsh.write(str(output_mesh_file))
            return meshio.read(str(output_mesh_file))
        else:
            # Return mesh data as temporary file
            temp_file = Path("temp_adaptive_mesh.msh")
            gmsh.write(str(temp_file))
            mesh_data = meshio.read(str(temp_file))
            temp_file.unlink()  # Clean up
            return mesh_data

    finally:
        if not already_initialized:
            gmsh.finalize()
